__Mutually Assured Destruction__

The only winning move is... to win?

Summary
	- Each player starts with some number of cities, some number of nukes, and
		some amount of money..
		+ Default to 3 cities and 5 nukes.
		+ Might make city, nuke, and money quantities configurable on new game.
	- Each nuke has an hourly or daily upkeep cost.
		+ No need to make this configurable. It would be equivalent to changing
			starting money.
			-> On second thought, this should be configurable if other values
				can be configured. For example, costs would need to be deducted
				much more frequently if nuke flight time is reduced to, let's
				say, 30 minutes (a realistic ICBM flight time, apparently).
	- When a player launches or dismantles a nuke, they no longer pay its
		upkeep cost.
	- All commands are sent to the bot in the group chat. All players can see
		all commands and bot announcements.
	- A player can permanently dismantle a nuke at any time.
	- A player can launch a nuke at any target at any time.
	- The launch command is sent to the bot in the group chat and the bot
		announces when the nuke will strike its target (default to 24 hours).
		The bot will probably also makes announcements every few hours. The
		targeted player may still choose to launch a nuke at any time.
		+ Default to 24 hours.
		+ Might make this configurable on new game.
	- When a nuke strikes its target, that city is destroyed.
	- When a player runs out of money or cities, that player is eliminated.
	- The last player standing after any nukes in flight strike their targets
		wins.

How to maintain state?
	- Probably slightly different from the RPG bot, where the state object was
		passed into the game object. It probably makes more sense for the
		state class to store the overall state of the bot for a given chat,
		including the game object itself.

Classes:

	state
		- Maintains the current state of the bot in a single chat, including any
			active games.
		- Members:
			+ game: An instance of the game object. Null (None) if there is no
				ongoing game.

	player
		- Represents an individual player.
		- Members
			+ cities: Collection of strings. Holds the names of the player's
				remaining cities.
			+ nukes: Integer keeping track of the player's remaining nukes.
			+ money: Integer keeping track of the player's remaining money.
	
	game
		- Keeps track of an ongoing game.
		- Members
			+ activePlayers: A list of player objects representing each player
				remaining in the current game.
				-> Probably a dictionary keyed by an ID provided by the caller
					(whatever unique ID Telegram gives users for the bot or an
					arbitrary value for the test harness).
			+ eliminatedPlayers: A collection of eliminated players and their
				causes of elimination (economic collapse or annihilation). This
				will be used when the scoreboard is displayed and at the end of
				the game when the final results are announced.
			+ upkeepPeriod: How often (in seconds?) upkeep cost is deducted.
				Will probably use one day and poll something like every minute
				but want to design for the possibility of allowing custom games.
			+ upkeepCost: The cost per upkeep period of owning a nuke.
			+ lastUpkeepTime: Datetime at which the last upkeep deduction
				occurred.
			+ inFlight: A collection of nukes that have been launched, their
				owners, their targets, and the datetimes at which they are
				scheduled to hit their targets.
			+ flightTime: How long a nuke takes to reach its target after launch.
			+ gameOver: False when a game is ongoing. True if the game has ended.
			+ gameStarted: False if the game has not yet started, meaning players
				can still join. True if the game has started.
		- Methods
			+ join(playerId, citieNames): Add a new player.
			+ start(): Close the game to new players and start playing.
				-> Sets lastUpkeepTime to current time.
			+ launch(player, target): Called when a player launches a nuke.
				-> Add a nuke to the inFlight collection.
			+ dismantle(playerId): Called when a player dismantles a nuke.
			+ getScoreboard(): Returns a string showing  the current state of the game:
				-> players
					- active/eliminated
					- remaining cities
					- remaining money
					- remaining nukes
				-> nukes in flight
					- owner
					- target
					- time to impact
			+ update: Periodically called by the bot/state class or a timer.
				-> Compares impact times in the inFlight collection to the
					current time and, if an impact should occur during this
					update, removes the impacting nukes from inFlight, removes
					the targeted cities from their owners' cities collections,
					and adds a message about the nukes hitting their targets to
					the output for this update.
					- Remember to handle the case where the targeted city was
						already destroyed by another nuke arriving earlier.
						"The crater once known as cityName gets a little deeper."
				-> Deducts upkeep if current time > lastUpkeepTime + upkeepPeriod.
				-> Eliminates players with $0 or less or 0 cities and adds a
					message about those eliminations to the output.
				-> Returns any output the bot should send to tell players
					about the game state.
				-> If the game has ended (at most one player remaining and no
					nukes in flight; or no nukes remaining in inventory or in
					flight), set gameOver and return a game over message stating
					the winner (if there is one) and displaying the final
					scoreboard.



TODO:

	Write design notes (see "Classes" above) until ready to start writing code.

	Consider writing a terminal application to test the game separately from
		the Telegram bot. This should make it more convenient to test the game
		logic with multiple "players" than trying to get others to help test
		through the Telegram bot.
	
	Search the .py files for "TODO" comments.
